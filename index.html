<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Lithium by BonsaiDen</title>

    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="javascripts/scale.fix.js"></script>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
  </head>
  <body>
    <div class="wrapper">
      <header>
        <h1 class="header">Lithium</h1>
        <p class="header">A data centric WebSocket library for both Node.js and the Browser.</p>

        <ul>
          <li class="download"><a class="buttons" href="https://github.com/BonsaiDen/lithium/zipball/master">Download ZIP</a></li>
          <li class="download"><a class="buttons" href="https://github.com/BonsaiDen/lithium/tarball/master">Download TAR</a></li>
          <li><a class="buttons github" href="https://github.com/BonsaiDen/lithium">View On GitHub</a></li>
        </ul>

        <p class="header">This project is maintained by <a class="header name" href="https://github.com/BonsaiDen">BonsaiDen</a></p>


      </header>
      <section>
        <h1>Lithium</h1>

<p><strong>Lithium</strong> is a data centric WebSocket library for both Node.js and the Browser.</p>

<h2>Installation</h2>

<h4>Client</h4>

<div class="highlight"><pre><span class="nt">&lt;script </span><span class="na">type=</span><span class="s">"text/javascript"</span> <span class="na">src=</span><span class="s">"lithium.client.js"</span><span class="nt">&gt;&lt;/script&gt;</span>
</pre></div>

<h4>Server</h4>

<pre><code>npm install lithium
</code></pre>

<h2>Usage</h2>

<p>Below is an example of a simple, JSON based echo server.</p>

<h4>Client</h4>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">client</span> <span class="o">=</span> <span class="nx">lithium</span><span class="p">.</span><span class="nx">Client</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">client</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">client</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'message'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">...</span>
    <span class="p">});</span>

    <span class="nx">client</span><span class="p">.</span><span class="nx">send</span><span class="p">({</span>
        <span class="nx">msg</span><span class="o">:</span> <span class="s1">'Hello World'</span>
    <span class="p">});</span>

<span class="p">},</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">);</span>
</pre></div>

<h4>Server</h4>

<div class="highlight"><pre><span class="kd">var</span> <span class="nx">lithium</span> <span class="o">=</span> <span class="nx">require</span><span class="p">(</span><span class="s1">'lithium'</span><span class="p">);</span>

<span class="kd">var</span> <span class="nx">server</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">lithium</span><span class="p">.</span><span class="nx">Server</span><span class="p">(</span><span class="kd">function</span><span class="p">(</span><span class="nx">remote</span><span class="p">)</span> <span class="p">{</span>

    <span class="nx">remote</span><span class="p">.</span><span class="nx">accept</span><span class="p">();</span>
    <span class="nx">remote</span><span class="p">.</span><span class="nx">on</span><span class="p">(</span><span class="s1">'message'</span><span class="p">,</span> <span class="kd">function</span><span class="p">(</span><span class="nx">msg</span><span class="p">)</span> <span class="p">{</span>
        <span class="nx">remote</span><span class="p">.</span><span class="nx">send</span><span class="p">(</span><span class="nx">msg</span><span class="p">);</span>
    <span class="p">});</span>

<span class="p">},</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">stringify</span><span class="p">,</span> <span class="nx">JSON</span><span class="p">.</span><span class="nx">parse</span><span class="p">);</span>

<span class="nx">server</span><span class="p">.</span><span class="nx">listen</span><span class="p">(</span><span class="mi">8000</span><span class="p">);</span>
</pre></div>

<h2>Features</h2>

<ul>
<li>WebSocket Protocols (v75, v76, hixie and hyby)</li>
<li>Binary Message Support</li>
<li>Consistent API on both Server and Client</li>
<li>No dependencies</li>
</ul><h2>API</h2>

<h3>Server</h3>

<p>A <code>http.Server</code>-like interface for managing web socket connections.</p>

<h4>Methods</h4>

<ul>
<li>
<p><strong>Constructor - lithium.Server([Function:callback] [, Function:encoder, Function:decoder])</strong></p>

<p>Creates a new server instance.</p>

<p>The optional <code>callback</code> argument is shortcut for the <code>connection</code> event.</p>

<p>If both the <code>encoder</code> and <code>decoder</code> arguments are present, messages will be 
passed to these functions when being send / received.</p>

<p>For example, in order to process and treat all messages as JSON objects pass</p>
</li>
<li>
<p><strong>listen(Number:port [, String:hostname])</strong></p>

<p>Makes the server listen for incoming web socket requests on <code>port</code> and - 
optionally - <code>hostname</code>.</p>
</li>
<li>
<p><strong>listen(http(s).Server)</strong></p>

<p>Makes the server listen for incoming web socket request on an existing 
instance of <code>http.Server</code> or <code>https.Server</code>.</p>
</li>
<li>
<p><strong>Array[Remote] - remotes([Function:filter])</strong></p>

<p>Returns a array with all remotes that are currently connected to the server 
(meaning that only accepted remotes will be contained in the array).</p>

<p>Filter is an optional function behaving much like <code>Array.filter</code> in that it 
filters the remotes before returning them.</p>
</li>
<li>
<p><strong>Integer - send(Any:message [, Function:filter])</strong></p>

<p>Sends a message to all <em>accepted</em> remotes on the server. </p>

<p>Filter is an optional function behaving much like <code>Array.filter</code> in that it 
filters the remotes before messaging them.</p>

<p>Returns the number of remotes the message was sent to.</p>
</li>
<li>
<p><strong>Boolean - close([string:reason])</strong></p>

<p>Closes the server by preventing any furhter connections to be made and 
invokes the <code>close</code> method of all the server's remotes.</p>

<p>The optional <code>reason</code> is only supported in newer versions of the WebSocket 
protocol and will be available as the <code>reason</code> property on the WebSocket's 
close event.</p>

<p>Returns <code>false</code> in case the server is already closed.</p>
</li>
</ul><h4>Events</h4>

<ul>
<li>
<p><strong>connection(Remote:remote)</strong></p>

<p>Emitted when a <code>remote</code> connects to the server.</p>
</li>
<li>
<p><strong>accepted(Remote:remote)</strong></p>

<p>Emitted when the server accepts a <code>remote</code>.</p>
</li>
<li>
<p><strong>rejected(Remote:remote)</strong></p>

<p>Emitted when the server rejects a <code>remote</code>.</p>
</li>
<li>
<p><strong>closed(Remote:remote, Boolean:closedByRemote)</strong></p>

<p>Emitted when a <code>remote</code> disconnects from the server.</p>

<p><code>closedByRemote</code> will be <code>true</code> in the case that the disconnect was initiated 
by the remote.</p>
</li>
<li>
<p><strong>close()</strong></p>

<p>Emitted when the server stops listening for new connections.</p>
</li>
</ul><h3>Remotes</h3>

<p>Each remote encapsulate a single web socket connection to a client.</p>

<p>A remote is only recognized as being connected after it was accepted.</p>

<h4>Properties</h4>

<ul>
<li><p><strong>String - id</strong></p></li>
<li>
<p><strong>String - address</strong></p>

<p>Address of the underlying socket connection.</p>
</li>
<li>
<p><strong>Intege - port</strong></p>

<p>Port of the underlying socket connection.</p>
</li>
<li>
<p><strong>Integer - bytesSend</strong></p>

<p>Number of raw bytes (including protocol overhead) send over the socket.</p>
</li>
<li>
<p><strong>Integer - bytesReceived</strong></p>

<p>Number of raw bytes (including protocol overhead) send over the socket.</p>
</li>
<li>
<p><strong>Integer - version</strong></p>

<p>The version of the underlying WebSocket protocol for this remote.</p>
</li>
</ul><h4>Methods</h4>

<ul>
<li>
<p><strong>Boolean - accept()</strong></p>

<p>Accepts a pending remote connection, which adds it to the list of connected 
remotes on the server.</p>

<p>Once a remote is accepted messages can be send to it.</p>

<p>Returns <code>true</code> in case the remote was accepted or <code>false</code> in case it could 
not be accepted.</p>
</li>
<li>
<p><strong>Boolean - reject([String:reason])</strong></p>

<p>Rejects a pending remote and sends an optional <code>reason</code> as a message before 
closing the connection. </p>

<p>Returns <code>true</code> in case the remote was rejected or <code>false</code> in case it could 
not be rejected.</p>
</li>
<li>
<p><strong>Boolean - isPending()</strong></p>

<p>Returns whether or not the connection is pending.</p>

<p>Pending means that the connection is yet to be either accepted or rejected.</p>
</li>
<li>
<p><strong>Object - info()</strong></p>

<p>Returns a object containing connection specific information:</p>

<pre><code>{
    ip: "127.0.0.1"
    port: 35758,
    bytesSend: 123,
    bytesReceived: 456
}
</code></pre>

<blockquote>
<p>Note: The returned object is a reference.</p>
</blockquote>
</li>
<li>
<p><strong>Boolean - send(any:message)</strong></p>

<p>Sends a <code>message</code> to the remote.</p>

<p>Returns <code>true</code> in case the message was send or <code>false</code> in case it could 
not be send.</p>
</li>
<li>
<p><strong>Boolean - close([Any:reason])</strong></p>

<p>Closes the connection to the remote. </p>

<p>The optional <code>reason</code> is only supported in newer versions of the WebSocket 
protocol and will be available as the <code>reason</code> property on the WebSocket's 
close event.</p>

<p>Returns <code>true</code> in case the connection was closed or <code>false</code> in case it 
was not.</p>
</li>
</ul><h4>Events</h4>

<ul>
<li>
<p><strong>message(Any:message)</strong></p>

<p>Emitted when a <code>message</code> is received from a remote. </p>
</li>
<li>
<p><strong>close(Boolean:closedByRemote)</strong></p>

<p>Emitted when the remote is disconnected from the server.</p>

<p><code>closedByRemote</code> will be <code>true</code> in the case that the disconnect was initiated 
by the remote.</p>
</li>
</ul><h3>Client</h3>

<p>A thin wrapper around the browser side <code>WebSocket</code> object, providing a 
interface that is consistent with the lithium server.</p>

<h4>Methods</h4>

<ul>
<li>
<p><strong>Constructor - lithium.Client([Function:callback] [, Function:encoder, Function:decoder])</strong> <em>(Constructor)</em></p>

<p>The optional <code>callback</code> argument is shortcut for the <code>connection</code> event.</p>

<p>If both the <code>encoder</code> and <code>decoder</code> arguments are present, messages will be 
passed to these functions when being send / received.</p>

<p>For example, in order to process and treat all messages as JSON objects pass</p>
</li>
<li>
<p><strong>Boolean - connect(Integer:port [, String:hostname])</strong></p>

<p>Connects to the server at <code>port</code> and - optionally - <code>hostname</code>.</p>
</li>
<li>
<p><strong>Boolean - isConnected()</strong></p>

<p>Returns <code>true</code> in case the client is currently connected to the server.</p>
</li>
<li>
<p><strong>Boolean - send(any:message)</strong></p>

<p>Sends a <code>message</code> to the remote.</p>

<p>Returns <code>true</code> in case the message was send or <code>false</code> in case it could 
not be send.</p>
</li>
<li>
<p><strong>Boolean - close()</strong></p>

<p>Closes the connection to the server.</p>

<p>Returns <code>false</code> in case the connection is already closed.</p>
</li>
</ul><h4>Events</h4>

<ul>
<li>
<p><strong>connection()</strong></p>

<p>Emitted once the connection to the server is established.</p>
</li>
<li>
<p><strong>message(Any:message)</strong></p>

<p>Emitted when a <code>message</code> is received from the server. </p>
</li>
<li>
<p><strong>close(Boolean:closedByServer)</strong></p>

<p>Emitted when the client is disconnected from the server.</p>

<p>In the case that the server has initiated the close of the connection, 
the value of <code>closedByServer</code> will be <code>true</code>.</p>
</li>
</ul><h2>License</h2>

<p><strong>Lithium</strong> is licensed under MIT.</p>
      </section>
      <footer>
        <p><small>Hosted on <a href="https://pages.github.com">GitHub Pages</a> using the Dinky theme</small></p>
      </footer>
    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
		
  </body>
</html>